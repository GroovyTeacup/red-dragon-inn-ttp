/**
 * A script for turning TabletopPlayground objects into turn counters.
 * To use, simply use one of makeTurnCounter or makeTurnCounterById specifying your object.
 * The offset refers to the relative position of the object when placed onto the card container.
 * Both the offset and the object are rotated to reflect that of the destination holder.
 * Mode can be one of color or state, with state calling setState with the slot number of the player.
 * An easy guideline for which player will be which is that it follows the order in properties for setting a holder's owner.
 * passButton and skipButton correspond to the scripting keys that will be used by players at the table.
 * If an invalid button is given to skipButton, then players will be unable to skip their turns.
 * Optionally the object and a slot can be supplied to toggleSkip to start / stop skipping that player.
 * timeout refers to when a player presses the passButton while it is not their turn. This requests the current turn transfer to them.
 * After timeout milliseconds, the request expires.
 */
const  {GameObject, world, globalEvents, Vector} = require("@tabletop-playground/api");

/**
 * Places an object onto the hand holder of a given player, offset by the given vector
 * @param {GameObject} object - The object being placed on the holder.
 * @param {Player} player - The player whose holder the object will be placed on.
 * @param {Vector} offset - The offset of the object relative to the center of the holder.
 */
function placeOnHand(object, player, offset) {
    let holder = player.getHandHolder();

    let offVec = holder.getRotation().rotateVector(offset);

    object.setObjectType(2);
    object.setPosition(offVec.add(holder.getExtentCenter()));
    object.setRotation(holder.getRotation());
    object.toggleLock();
}

/**
 * Finds the next valid player on the table.
 * @param {GameObject} object - Object used for determining skips.
 * @param {Player} player - The player that the search will start from.
 * @returns {Player} The first player encountered.
 */
function getNextPlayer(object, player) {
    let next = player.getSlot() + 1;
    while (!world.getPlayerBySlot(next)) {
        next++;

        if (next > 9) {
            next = 0;
        }

        if (object.skip[next]) {
            next++;
        }
    }
    return world.getPlayerBySlot(next);
}

/**
 * Changes the object's appearance and location to reflect the current player.
 * @param {GameObject} object - Object that is being modified.
 * @param {Player} player - The player the object is being changed to match.
 * @param {string} mode - One of "state" or "color", defines how the object changes to reflect the player. If neither, remains unchanged.
 * @param {Vector} offset - Destination offset of the object.
 */
function setPlayer(object, player, mode, offset) {
    object.currPlayer = player;

    switch (mode) {
        case "state" :
            object.setState(player.getSlot());
            break;
        case "color" :
            object.setPrimaryColor(player.getPlayerColor());
            break;
        default:
            break;
    }

    placeOnHand(object, player, offset);
}

/**
 * Toggles if the turn counter is skipping the provided slot.
 * @param {GameObject} object - The object being used as a turn counter.
 * @param {Vector} slot - The slot of the player the object might be skipping.
 * @returns {Boolean} Whether the object is skipping the provided slot.
 */
function toggleSkip(object, slot) {
    object.skip[slot] = !object.skip[slot];
    return object.skip[slot];
}

/**
 * Determines if the turn counter is skipping the provided slot.
 * @param {GameObject} object - The object being used as a turn counter.
 * @param {Vector} slot - The slot of the player the object might be skipping.
 * @returns {Boolean} Whether the object is skipping the provided slot.
 */
function isSkipping(object, slot) {
    return object.skip[slot];
}

/**
 * Makes the supplied object into a turn counter.
 * @param {GameObject} object - The object being used as the holder.
 * @param {Vector} offset - The offset relative to the center of the holders to place the object.
 * @param {string} mode - One of "state" or "color", defines how the object changes to reflect the player. If neither, remains unchanged.
 * @param {number} passButton - The scripting button players can press to pass the turn.
 * @param {number} skipButton - The scripting button players can press if they want to be skipped, invalid to disable.
 * @param {number} timeout - The timeout for transfer requests, if <0 disabled.
 */
function makeTurnCounter(object, offset, mode = "color", passButton = 1, skipButton = 2, timeout = 30000) {
    try {
        setPlayer(object, world.getAllPlayers()[0], mode, offset);
    } catch (err) {
        console.log("Error: failed to find a card container while initializing, continuing.");
    }
    object.waitPlayer = null;

    object.skip = [false, false, false, false, false, false, false, false, false, false];

    globalEvents.onScriptButtonReleased.add(function(player, button) {
        if (button === passButton && !object.skip[player.getSlot()]) {
            if (player === object.currPlayer) {
                if (object.waitPlayer != null) {
                    object.currPlayer.showMessage("Turn transferred.");
                    object.waitPlayer = null;
                    setPlayer(object, object.waitPlayer, mode, offset);
                    object.currPlayer.showMessage("It's your turn.");
                } else {
                    object.currPlayer.showMessage("Turn ended.");
                    setPlayer(object, getNextPlayer(object, object.currPlayer), mode, offset);
                    object.currPlayer.showMessage("It's your turn.");
                }
            } else if (timeout > 0 && object.waitPlayer == null) {
                object.currPlayer.showMessage("Player ".concat(
                    player.getName(), " wants to take their turn, press scripting key ",
                    passButton.toString(), " to transfer turn."));

                object.waitPlayer = player;
                setTimeout(function() {
                    object.waitPlayer = null;
                }, timeout);
            }
        }
    });

    if (skipButton < 10 && skipButton >= 0) {
        globalEvents.onScriptButtonReleased.add(function(player, button) {
            if (button === skipButton) {
                object.skip[player.getSlot()] = !object.skip[player.getSlot()];
                if (object.skip[player.getSlot()]) {
                    player.showMessage("Enabled turn skipping.");
                }
                else {
                    player.showMessage("Disabled turn skipping.");
                }
            }
        });
    }
}

/**
 * Finds the object corresponding object and makes it into a turn counter.
 * @param {string} id - The id of the object being used as the holder.
 * @param {Vector} offset - The offset relative to the center of the holders to place the object.
 * @param {string} mode - One of "state" or "color", defines how the object changes to reflect the player. If neither, remains unchanged.
 * @param {number} passButton - The scripting button players can press to pass the turn.
 * @param {number} skipButton - The scripting button players can press if they want to be skipped, invalid to disable.
 * @param {number} timeout - The timeout for transfer requests, if <0 disabled.
 */
function makeTurnCounterById(id, offset = new Vector(0, 0, 0), mode = "color", passButton = 1, skipButton = 2, timeout = 30000) {
    let object = world.getObjectById(id);
    makeTurnCounter(object, offset, mode, passButton, skipButton, timeout);
}

module.exports.makeTurnCounter = makeTurnCounter;
module.exports.makeTurnCounterById = makeTurnCounterById;
module.exports.toggleSkip = toggleSkip;
module.exports.isSkipping = isSkipping;